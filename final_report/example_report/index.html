<!DOCTYPE html>
<html>
<title>Sakana Milk Battles: The Game</title>

<xmp theme="united" style="display:none;">
# Overview

This entire page is written using [markdown](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet), which let's you generate cleaner-documents that can be readily rendered in a lot of environments (including the web).  In the context of this template, the markdown is interpretted by a javascript library for you found <a href="http://strapdownjs.com/" target="_blank">here</a>.  This library also let's you pretty conveniently change the theme to one of about a dozen options (See the link). You can also always fall back on traditional html <a href="https://en.wikipedia.org/wiki/Markdown" target="_blank">as I am doing in this link and the previous one</a>.  Feel free to ask questions on piazza, but hopefully this document provides a good list of examples of how to do most things.  

You do not have to use this template. All we want is a nice, clean web-friend report so you can do it in one page as shown here, or in multiple linked pages. However you'd like.  

## Overall Design

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore
et dolore magna aliqua.  Random Words.  Random Words. This is America. This is America. Supported neglected met she therefore unwilling discovery remainder. Way sentiments two indulgence uncommonly own. Diminution to frequently sentiments he connection continuing indulgence. An my exquisite conveying up defective. Shameless see the tolerably how continued. She enable men twenty elinor points appear. Whose merry ten yet was men seven ought balls. 

Image example:

<center>
	<img src="./media/board_v1.jpg" width="300"/>
</center>

Both rest of know draw fond post as. It agreement defective to excellent. Feebly do engage of narrow. Extensive repulsive belonging depending if promotion be zealously as. Preference inquietude ask now are dispatched led appearance. Small meant in so doubt hopes. Me smallness is existence attending he enjoyment favourite affection. Delivered is to ye belonging enjoyment preferred. Astonished and acceptance men two discretion. Law education recommend did objection how old. 

Built purse maids cease her ham new seven among and. Pulled coming wooded tended it answer remain me be. So landlord by we unlocked sensible it. Fat cannot use denied excuse son law. Wisdom happen suffer common the appear ham beauty her had. Or belonging zealously existence as by resources. 

Abilities or he perfectly pretended so strangers be exquisite. Oh to another chamber pleased imagine do in. Went me rank at last loud shot an draw. Excellent so to no sincerity smallness. Removal request delight if on he we. Unaffected in we by apartments astonished to decisively themselves. Offended ten old consider speaking. 

Locally hosted video embedded:

<center>
	<video width="500" height="400" controls>
  <source src="./media/6s08_EX02_final_product.mp4" type="video/mp4" >
Your browser does not support the video tag.
</video>
</center>

<center>
	<iframe src="https://giphy.com/embed/g0vZLllSiQielcNPae" width="480" height="270" frameBorder="0" allowFullScreen></iframe>
</center>




## System Design

Functional block diagram of the system:

<center>
	<img src="./media/systemblockdiagram.jpg" width="600"/>
</center>

Insert description here.

State machine block diagram:

<center>
	<img src="./media/schematic_1.png" width="600"/>
</center>

Insert description here.

Lists are great. This summer I'm going to:

* Eat ice cream
* Explore the websockets capabilities of the ESP32 more
* Work within the Intel/Altera toolchain more

## Documentation of code

The code is primarily on two files: server.py and esp32.ino.

###Server-side code

server.py takes care of all the server-side code, which involves handling GET and POST requests from the ESP32. When these two types of requests are made, the function `request_handler(request)` is called. All GET and POST requests pass in values for `action`, `player_ID`, and `game_ID` as query arguments.

Depending on the value of `action`, which indicates the action that the user just performed in the game, the code will process this accordingly.

####POST Requests

If the request is a POST request and the value of `action` is:

* 2, 3, or 4, the action was a slash, push, or block, respectively.<br/><br/>
The section of the code handling these cases will call the helper function `add_action(game_ID, player_ID, action)`, which updates `gestures_table` with this new action. (Helper functions are described in more detail later.)<br/><br/>
The data from the `game_table` corresponding to the current game is then extracted using the helper function `extract_game_info(game_ID)`.<br/><br/>
If this game is not ongoing (its `game_state` is not `1`), the health of the player who made the POST request, `game_state`, and `game_ID` is returned as a string.<br/><br/>
Otherwise if the game is ongoing, the last gesture from each player that hasn't been taken into account yet is extracted from the database via the helper function `extract_player_gestures(player_1, player_2)`. Based on these gestures, the helper function `health_update(health_1, health_2, action_1, action_2)` returns the updated healths of the two players and `update_game_info(game_ID, health_1, health_2, game_state)` updates the healths and game state in `game_table`.<br/><br/>
The health of the player who made the POST request, `game_state`, and `game_ID` is then returned as a string.<br/><br/>

* 7, the action was a button press, meaning that a player is trying to start a game.<br/><br/>
This section of the code checks `gestures_table` to see if another player has also tried starting a game in the last 3 seconds (and if they haven't already been matched with someone). It gets the most recent entry matching these specifications, creates a new game with both of these players in `game_table`, and marks both of the corresponding entries in the `gestures_table` as matched (`checked=1`). The player who first pressed the button to start the game is `player_1` and the other `player_2`.<br/><br/>
If there are no entries, it returns `"-1,0,-1"`.<br/><br/>

####GET Requests

If the request is a GET request and the value of `action` is:

* 1, the code checks the `game_table` for the most recent entry of an ongoing game where `player_1` matches the `player_ID` passed as an argument. (The player who first pressed the button to start the game never received the game information during their POST request with `action=7`, so they must post GET requests to get this information.) It returns the health of `player_1`, `game_state`, and `game_ID` as a string.

* 8, the code calls the helper function `extract_game_info(game_ID)` and returns the health of the player who made the POST request, `game_state`, and `game_ID` as a string.

Both these requests return `"-1,0,-1"` if the database table query returns no matching entries.

####Helper Functions

* `dict_factory(cursor, row)`: Converts SQL rows to dictionary format. This is used to set the `conn = sqlite3.connect(game_db)` setting so that all queries to the database return a dictionary. Modified from [here](https://stackoverflow.com/a/3300514).

* `add_action(game_ID,player_ID,action_ID,time=now,checked=0)`: Adds an entry to `gestures_table` with the corresponding inputs and returns nothing.

* `update_game_info(game_ID, health_1, health_2, game_state)`:    Goes into `game_table` updates the row with this `game_ID` with these values. Returns game state.

* `extract_game_info(game_ID)`: Takes in the `game_ID` and goes into `game_table`. Returns the most recent row containing the game_ID as a dictionary of the game information. 

* `extract_player_gestures(player_1, player_2)`: Looks at gesture database and finds the two most recent rows where one is `player_1` and one is `player_2`. The timestamp of the rows must be within one second and `checked` for both must equal `0`. If one of the two rows has an action that is not block, change the `checked` value in that database row to `1`. If they're not, one of the players is `None`. Returns a dictionary of the player name and their action. 

* `health_update(cur_health_1, cur_health_2, action_1, action_2)`: Takes in the current healths of both players and the last action each of them made. Returns the updated healths of both players as a list.


###ESP32 code

####Libraries

* `mpu9255_esp32.h`: Allowed used of magnetometer and acceleratometer of IMU.
* `adp5350.h`: For regulated use of a battery and power management.
* `U8g2lib.h`: Allowed oled access for initial debugging (not used in final product).
* `compass.h`: Used to calibrate the magnetometer. 
* `math.h`: For calculations like the magnitude of the magnetometer readings (for blocking).
* `WiFi.h`: Wifi access to interact with server.
* `SPI.h`: For screen use.
* `DFRobotDFPlayerMini.h`: Allowed use of music player/speakers.
* `Arduino.h`: Main arduino header file.
* `Adafruit_NeoPixel.h`: LED control.

####Setup()

* Serial setup for debugging while plugged into laptop.

* Wifi initialization to be able to interact with the server-side code.

* ADP5350 setup to turn on charging, voltage reading, and enabling the LDO ports. 

* IMU setup - done in a helper function that calibrates and starts it.

* Oled setup  for initial debugging purposes.

* LED strip initialization - put at rgb(50,0,50).

* Button pullup used for starting a game and waking up from sleep.

* Magnetometer calibration for use of blocking gesture.

* Primary_timer, get_timer, and power_timer set to millis() for timing uses later on.

* Speaker initialization. 

* Power variable intially set to true to indicate that the ESP should be on (as opposed to sleeping with little use). 

####Loop()

#####Awake vs Asleep
* There are two parts to the loop. If the global variable is true, the code loops through a separate function called loop_on(), which is our state machine and all other integrated code functions. The other part is sleep mode. When the IMU has little movement for more than power_threshold time (currently sent to 60 seconds), the ESP will go into light sleep, and the LEDs will turn off. The ESP will get out of this and go back into the loop_on() part when the button on the board is pressed.

#####Switch State Machine

There are four switch states that control the entire game.

* Case `GAME_RESTING`: In this state, the board is waiting for a game to begin. In case it is reentering this state after just finishing a game, it resets the global game variables game_ID, health, data_timer, and game_state. If the button is pressed, it does `do_POST(7)` (see helper function documentation for this) and causes the next loop to go to `WAITING_TO_START`.

* Case `WAITING_TO_START`: In this state, the player is trying to start a game with the other person. To know if the other person has also pressed the button to try to start a game, it continuously does `do_GET(1)` (see helper function documentation) until the button is no longer pressed, in which case it returns to `GAME_RESTING` because the player has given up on trying to start a game, or if the global variable `game_state` has been changed to 1, which means in game, it will go to `IN_GAME`. This variable is changed by the server information coming back from the constant GET request. If the other player has also posted that they are trying to start a game, and if both of them get the game_state as 1 infromation back form the server, that is when they both go into `IN_GAME`.

* Case `IN_GAME`: There are several things that happen while both players are in game. First, it is checked if the variable `get_timer` has reached the `get_thres`. If it has, it does `do_GET(8)`, which checks the progress of the game from the server in terms of their own health, the state of the game, and the game id. This is useful when the other person has attacked but this player has not done a move in a while. Without this GET request, the player would never know they have lost points until they make a move themselves. 

  Next, `gesture_stuff()` (see helper function documentation) is called, which updates the global variable current_action. This variable is what move the player is currently making. This can be 'Slash', 'Push', 'Block', or None. Depending on what move the person has made, it goes into a certain if statement. Before this, though, `has_happened(current_action)` checks whether `current_action` has just been posted or if this is a new move. Without this check, one slash move would post a slash to the server multiple times. However, blocking moves do post to the server continuously, since the server has to know if a player is currently blocking while a counter-move is made. 

  Depending on the move, the MP3 player will player the song associated with the gesture. Then, a post request will be made with the appropriate gesture number sent to the server (2 for slash, 3 for push, 4 for block). `get_timer` is also reset since the global game variables were just updated (and the ESP doesn't need to check again as soon to find out the status of the game). 

  Finally, if the global variable `game_state` has been changed to 2 from the information coming back from the server, it checks whether you have won or lost. A `game_state` value of 2 means that the game is over. If the player's health is 0 when this happens, it means the player has lost. It then plays the loser music out of the speakers and moves back into `GAME_RESTING` to play another game. If the player's health is greater that 0, the player must have won since the game is over, so it plays the winner music and moves back into `GAME_RESTING`.

* Case `GESTURE_RECOGNITION`: This is in place in case we want to collect more gestures for the correlation data. More gesture collection from more people will make the correlations and therefore the gesture recognition better. 


####Helper Functions

* `printDetail(uint8_t type, int value)`: This is an MP3 helper function that allows for diagnosis of what is going on with the module.

* `setup_imu()`: Initializes, calibrates, and starts the IMU module for use with the accelerometer (for slashing and pushing) and magnetometer (for blocking).

* `record_IMU_data()`: Reads the acceleromter data from the IMU and then sets the global variable `sum` to the root of its squares. The global variable `data` is also appended with the x, y, and z values for the correlation database. 

* `magnetometer()`: Reads the magnetometer data from the IMU. It then calculates the magnitude of the x, y, and z values and compares it to a threshold. If the magnitude is greater than the threshold, the function returns true. This means that a blocking motion is being made and is used by the gesture functions. Otherwise, returns false. 

* `speaker_begin()`: Initializes the MP3 player.

* `do_POST(int action)`: This does a POST request to the server with the location /608dev/sandbox/smathew/final_project/server.py. It sends the values of action, player_ID, and game_ID. The action value is passed in, and it is the current action that is being made by the player. This is called in the loop when in game and a gesture has been determined to have been made. The action can be slash (2), push (3), or block (4). The player_ID is a string identifying the user. The game_ID starts as -1, but when it first starts a game, this is changed to a value given by the server to both players. This function is also called when starting a game with the `action` of 7. This means that the player has pressed the button and is waiting to start a game. 

  The server sends back three values: health, game_state, and game_ID. `health` is the current health of the player. `game_state` is either 0 for not in game, 1 for in game, or 2 for game over. `game_ID` starts at -1 but is assigned a value by the server once in a game. These values are then parsed and set to the global variables with the helper function `parse_received(String op)`.

* `do_GET(int act)`: This sends a GET request to the server in the same location as the POST request. It sends `act`, `player_ID`, and `game_ID`. `act` is either a 1 or an 8. When it is a 1, it is when the player is first trying to start a game and looking to see if the other person has also tried to start a game. An 8 means that the player is currently in a game and checking what their own health is (in case the other player made a move while they weren't doing anything). The GET request receives back the same three values as the POST and parses them in the same manner. 

* `oled_print(String message)`: Was used to print text to the oled when used for debugging. 

* `wifi_setup()`: Connects to the wifi.

* `parse_received(String op)`: Takes the data coming back from the POST and GET requests. Information from the server comes back as a string in the form of #,#,#. This parsed based on comma location and sets the global variable `health` to the first number, `game_state' to the second, and `game_ID` to the third. 

* `print_wakeup_reason()`: Used for when the ESP32 is set to sleep from inactivity. It prints the wakeup reason to Serial.

* `update_current_act()`: MURD

* `update_list(float running_vals[avg_ges_len], float val)`: MURD

* `update_charged()`: MURD

* `cross_corr(float &corr_val, float running_vals[avg_ges_len], float corr_vals[avg_ges_len])`: MURD

* `set_corr_vals(float &corr_x, float &corr_y, float &corr_z, float &corr_val, float gesture_xs[avg_ges_len], float gesture_ys[avg_ges_len], float gesture_zs[avg_ges_len])`: MURD

* `gesture_stuff()`: MURD

* `has_happened(String action)`: MURD

* `update_leds(uint32_t c)`: MURD



</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</html>
